"""
Takes in a series of sine waves generated by mathEncode.py and decomposes them
using a discrete Fourier Transform to translate to a message. Amlpitudes of
decomposed waves correspond to letters and frequencies correspond to position
in the messageself.

Global variables must match mathEncode.py to decode successfully.
"""

import numpy as np
import matplotlib.pyplot as plt
import string

# GLOBAL VARIABLES
DURATION = round(2*np.pi) # Sets length of time for each "sound wave"
LENGTH = 50 # Sets nuber of letters for each "sound wave"
FREQ_LIST = [] # The list of frequencies we care about, assigns each one to a position in the message
for i in range(LENGTH):
    FREQ_LIST.append((i+1)*np.pi)

AMP_DICT = {'0':0, ' ':0} # Maps each letter to the corresponding amplitude
alphabet = string.ascii_lowercase
amps = np.linspace(1, 26, 26)
for i in range(len(alphabet)):
    AMP_DICT[alphabet[i]]=amps[i]
for i in range(len(string.punctuation)):
    AMP_DICT[string.punctuation[i]] = 0

INV_AMP_DICT = {v: k for k, v in AMP_DICT.items()} # Inverts dictonary for decoding
INV_AMP_DICT[0] = ' '

# FUNCTIONS
def Riemann(signal, ts, bound):
    """
    signal is our discrete function (air pressure as a function of time), bound is the domain we are "integrating" over
    """
    t1, t2 = bound
    dx = DURATION/(len(ts)-1)
    #print(dx)
    start_index = int(t1/dx)
    stop_index = int(t2/dx)

    total = 0
    for i in range(start_index, stop_index):
        total += dx * signal[i]
    return total

def pure_sine(amp, freq):
    """
    Given an amplitude and a frequency, generates an array that contains discrete
    values from a sine wave of that amplitude and frequency
    """
    ts = np.linspace(0, DURATION, (5000*(DURATION))+1)
    sine = []
    for i in range(len(ts)):
        sine.append(amp*np.sin(ts[i]*freq))
    return sine

def coefficient(signal, freq, domain=(0, 1)):
    """
    Calculates Fourier coefficient of the signal at a given frequency. This
    coefficient corresponds to the amplitude of the decomposed wave at this
    frqeuncy, which corresponds to a letter.
    """
    ts = np.linspace(0, DURATION, (5000*(DURATION))+1)
    sine = pure_sine(1, freq)
    b = (2/DURATION) * Riemann(np.multiply(signal, sine), ts, domain)
    return b

def decode(signal):
    """
    Iterates through the list of signals and decomposes each to an amplitudes and
    frequencies, which it converts back to text. Returns the concatenated string.
    """
    message = ''
    for i in range(len(signal)):
        chunk = signal[i]
        for j in range(len(FREQ_LIST)):
            amp = coefficient(chunk, FREQ_LIST[j], domain=(0, DURATION)) # TODO: make this not this way
            message = message + INV_AMP_DICT[round(amp)]
    return message

if __name__ == "__main__":
    signal = np.load("signal.npy")
    message = decode(signal)
    print(message)
